<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PPO算法目标函数理解</title>
      <link href="/2022/03/02/ai-readpaper-pponote/"/>
      <url>/2022/03/02/ai-readpaper-pponote/</url>
      
        <content type="html"><![CDATA[<p>本文主要针对<a href="https://arxiv.org/abs/1707.06347">PPO</a>[<a href="https://zhuanlan.zhihu.com/p/438102587#ref_1">1]</a>算法的<strong>目标函数</strong>谈一点自己的理解，刚刚入门的小白，文中不对之处还望各位大佬批评指正。</p><p>PPO主要针对<a href="https://arxiv.org/abs/1502.05477">TRPO</a>[<a href="https://zhuanlan.zhihu.com/p/438102587#ref_2">2]</a>算法进行了改进，在保证具有TRPO算法性能的基础上，PPO实现更加简单，更具有通用性，同时有着更好的采样复杂度。</p><h2 id="Trust-Region-Methods"><a href="#Trust-Region-Methods" class="headerlink" title="Trust Region Methods"></a><strong>Trust Region Methods</strong></h2><p>策略梯度的目标函数为：<br>$$<br>L^{PG}(\theta) &#x3D; \hat{E}t [log \;\pi{\theta}(a_t | s_t)\hat{A_t}]\tag{1}<br>$$</p><p>置信域方法的目标函数为：    </p><p>$$<br>\begin{aligned}<br>\underset{\theta} {maximize} \quad \hat{E}t[\frac{\pi_\theta(a_t|s_t)}{\pi{\theta_{old} }(a_t|s_t)}\hat{A_t}] \\\<br>subject; to \quad \hat{E}t\bigg[KL[\pi{\theta_{old} }(\cdot |s_t),\pi_\theta(\cdot |s_t)]\bigg]<br>\end{aligned}\tag{2}<br>$$</p><p>根据(2)式可见置信域方法在策略梯度的基础上增加了约束，限制前后两个策略差异不大，而KL散度是衡量两个策略差异的。置信域方法解决了参数更新过快导致的难以收敛的问题。</p><p>之后提出的TRPO改进方法，将(2)式转换为了一个无约束的优化问题：  </p><p>$$<br>\underset{\theta} {maximize} \quad \hat{E}t\bigg[\frac{\pi_\theta(a_t|s_t)} {\pi{\theta_{old} }(a_t|s_t)}\hat{A_t}-\beta KL[\pi_{\theta_{old} }(\cdot |s_t),\pi_\theta(\cdot |s_t)]\bigg]\tag{3}<br>$$</p><p>但系数 $\beta$ 的选择是一个比较困难的问题，直接选用一个固定的参数进行SGD更新的效果并不会很好。</p><h2 id="Clipped-Surrogate-Objective"><a href="#Clipped-Surrogate-Objective" class="headerlink" title="Clipped Surrogate Objective"></a><strong>Clipped Surrogate Objective</strong></h2><p>对于(2)式，如果令$r_t(\theta)&#x3D;\frac{\pi_\theta(a_t |s_t)}{\pi_{\theta_{old}}}$ ,那么即可得到：   </p><p>$$<br>\begin{eqnarray}L^{CPI}(\theta)&#x3D;\hat{E}t\bigg[\frac{\pi_\theta(a_t|s_t)} {\pi{\theta_{old} }(a_t|s_t)} \hat{A_t}\bigg] &#x3D; \hat{E}_t\bigg[ r_t(\theta)\hat{A_t}\bigg]\end{eqnarray}\tag{4}<br>$$</p><p>如果对(4)式求最大值，会导致前后两个策略差异过大，也就是会<strong>导致</strong>$r_t(\theta)$<strong>过于偏离1</strong>， 影响性能，那么需要对(4)式进行修改，限制策略差异大小，即<strong>对</strong>$r_t(\theta)$<strong>设置一个范围</strong>   </p><p>$$<br>\begin{eqnarray}L^{CPIP}(\theta)&#x3D;\hat{E}_t\bigg[min( r_t(\theta)\hat{A_t},clip(r_t(\theta),1-\epsilon,1+\epsilon)\hat{A_t})\bigg]\end{eqnarray}\tag{5}<br>$$</p><p>其中$clip(x,up,down)$表示将x限制范围$[up,down]$ ,那么(5)式就将$r_t(\theta)$限制在$(1-\epsilon,1+\epsilon)$之间，一般取$\epsilon &#x3D; 0.2$，(5)式也就是PPO的目标函数，论文中对于(5)式进行了绘图表示。</p><p><img src="/2022/03/02/ai-readpaper-pponote/v2-5c9fff5eef1206226b29e97b44e66a63_r.jpg" alt="图1"></p><p>通过图1，并结合(5)式，那么可以将(5)式修改为：<br>$$<br>\begin{eqnarray}<br>\begin{aligned}<br>if \quad &amp;\hat{A_t}&gt;0\quad<br>L^{CLIP}(\theta)&#x3D;\begin{cases} (1+\epsilon) \hat{A_t} \quad &amp;r_t(\theta)&gt;1+\epsilon \\\<br>L^{CPI}&#x3D;r_t(\theta) \hat{A_t} \quad &amp;else\end{cases}\\\<br>if \quad &amp;\hat{A_t}&lt;0 \quad<br>L^{CLIP}(\theta)&#x3D;\begin{cases} (1-\epsilon)\hat{A_t}\quad &amp;r_t(\theta)&lt;1-\epsilon \\\<br>L^{CPI}&#x3D;r_t(\theta) \hat{A_t} \quad &amp;else\end{cases}<br>\end{aligned}\end{eqnarray}\tag{6}<br>$$<br>$\hat{A_t}$代表t时刻的优势函数，$\hat{A_t}$大于0表示此时策略更好，要加大优化力度。目标函数$L^{CLIP}(\theta)$取最大，那么就会<strong>尽量取大的$r_t(\theta)$<strong>。但如果</strong>更新力度过大，新旧策略差异太大，即$r_t&gt;1+\epsilon$<strong>，显然这不是我们希望的，那么</strong>clip操作和min操作会选择$r_t&#x3D;1+\epsilon$</strong>,这样就将最大的$r_t$限制到了$1+\epsilon$，防止了过度优化。</p><p>同样$\hat{A_t}$小于0表示此时策略更差，要减小优化力度，目标函数$L^{CLIP}(\theta)$取最大，那么就会<strong>尽量取小的$r_t(\theta)$<strong>。但如果</strong>更新力度过大，新旧策略差异太大，即$r_t&lt;1-\epsilon$<strong>，显然这不是我们希望的，那么</strong>clip操作和min操作会选择$r_t&#x3D;1-\epsilon$</strong>,这样就将最大的$r_t$限制到了$1-\epsilon$，减小了更新力度。</p><p>通过以上解释，对比TRPO的目标函数(式(2,3))和PPO的目标函数(式(5))，可以看到PPO的目标函数在限制前后策略差异不大的同时，避免了超参数的$\beta$调整的难度。仅从目标函数，就可以看到PPO算法在保障TRPO算法性能的同时，实现上更加简单。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/438102587#ref_1_0">^</a>John Schulman et al, Proximal Policy Optimization Algorithms: <a href="https://arxiv.org/abs/1707.06347">https://arxiv.org/abs/1707.06347</a></li><li><a href="https://zhuanlan.zhihu.com/p/438102587#ref_2_0">^</a>John Schulman et al , Trust Region Policy Optimization: <a href="https://arxiv.org/abs/1502.05477">https://arxiv.org/abs/1502.05477</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> PaperRead </tag>
            
            <tag> RL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针&amp;链表</title>
      <link href="/2022/03/02/ag-doublepointer/"/>
      <url>/2022/03/02/ag-doublepointer/</url>
      
        <content type="html"><![CDATA[<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h2><p><img src="/2022/03/02/ag-doublepointer/1645971484076-c26dec60-ae41-4a8d-a968-accbb4563304.png" alt="img"></p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>反转链表，仅仅需要扭转链表的指向顺序即可，如果用双指针实现的话，一个快指针，一个慢指针指向相邻的两个结点，并将结点的指向顺序改变即可。</p><p>思考一些细节问题，在扭转之前，我们需要一个空指针作为扭转后的尾部。</p><p>好，看代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">  ListNode<span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ListNode<span class="token operator">*</span> p0 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>      ListNode<span class="token operator">*</span> p1 <span class="token operator">=</span> head<span class="token punctuation">;</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      ListNode<span class="token operator">*</span> p2 <span class="token operator">=</span> p1<span class="token operator">-></span>next<span class="token punctuation">;</span>            p1<span class="token operator">-></span>next <span class="token operator">=</span> p0<span class="token punctuation">;</span>          p0 <span class="token operator">=</span> p1<span class="token punctuation">;</span>          p1 <span class="token operator">=</span> p2<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> p0<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有几个点需要注意：</p><ul><li><p>p0 作为 左指针， p1作为右指针</p></li><li><p>line6 首先要记录下p1的下一个指针，因为反转之后就变了</p></li><li><p>line8 一定要在line9之前</p></li></ul><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ListNode<span class="token operator">*</span> p0 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> p1 <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        ListNode<span class="token operator">*</span> p2 <span class="token operator">=</span> p1<span class="token operator">-></span>next<span class="token punctuation">;</span>              p1<span class="token operator">-></span>next <span class="token operator">=</span> p0<span class="token punctuation">;</span>            p0 <span class="token operator">=</span> p1<span class="token punctuation">;</span>            p1 <span class="token operator">=</span> p2<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">return</span> p0<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><p><img src="/2022/03/02/ag-doublepointer/1645954811592-dbacf012-5d2b-48ba-838d-064cc1b87c71.png" alt="img"></p><h3 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h3><p>常规思路是先求出链表的长度，然后找到删去的结点删除，但要进行两次遍历。</p><p>如何才能够通过一次遍历实现呢？双指针中的快慢指针，让两个指针差n个单位，就可以找出要删除的结点进行删除。</p><p>那很容易想到应该写如下代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode<span class="token operator">*</span> ptr1 <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> ptr1 <span class="token operator">=</span> ptr1<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ListNode<span class="token operator">*</span> ptr2 <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>ptr1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    ptr1 <span class="token operator">=</span> ptr1<span class="token operator">-></span>next<span class="token punctuation">;</span>    ptr2 <span class="token operator">=</span> ptr2<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们思考上述代码会出现怎样的问题，我们只思考指针ptr2的起始位置即可。</p><p>以官方第一个例子为例</p><p><strong>输入：</strong>head &#x3D; [1,2,3,4,5], n &#x3D; 2 </p><p><strong>输出：</strong>[1,2,3,5]</p><p>ptr2指向第一个结点的时候，ptr1指向第三个结点，那么当ptr1指向nullptr时，ptr2 刚好指向倒数第2个结点。</p><p>这样我们就无法删除该结点，因此我们需要ptr2指向倒数第3个结点，那很好解决，直接让ptr1多走一个即可。</p><p>但还会出现问题，如果链表只有一个结点，并且n&#x3D;1，那么代码2-4行就会报错。那么怎么解决呢？既然ptr1不能多往后移动，那么我们可以让ptr2多往前移动。（注：当然可以将特殊情况摘出，但算法追求的更是一种通用解法）那么我们就需要在head前添加一个哑结点。</p><p>即</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode<span class="token operator">*</span> ptr1 <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> ptr1 <span class="token operator">=</span> ptr1<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ListNode<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>ListNode<span class="token operator">*</span> ptr2 <span class="token operator">=</span> dummy<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>ptr1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    ptr1 <span class="token operator">=</span> ptr1<span class="token operator">-></span>next<span class="token punctuation">;</span>    ptr2 <span class="token operator">=</span> ptr2<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">deleteNodenList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ListNode<span class="token operator">*</span> ptr1 <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ptr1 <span class="token operator">=</span> ptr1<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ListNode<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> ptr2 <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>ptr1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ptr1 <span class="token operator">=</span> ptr1<span class="token operator">-></span>next<span class="token punctuation">;</span>            ptr2 <span class="token operator">=</span> ptr2<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ptr2<span class="token operator">-></span>next <span class="token operator">=</span> ptr2<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 找工作 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
